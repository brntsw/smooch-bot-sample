'use strict';

exports.__esModule = true;
exports.AppUsersApi = undefined;

var _base = require('./base');

var _appUsersStripe = require('./appUsersStripe');

var _appUsersViber = require('./appUsersViber');

var _appUsersWeChat = require('./appUsersWeChat');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Init API properties
 * @typedef InitProps
 */

/**
 * @class AppUsersApi
 * @extends BaseApi
 */

var AppUsersApi = exports.AppUsersApi = function (_BaseApi) {
    _inherits(AppUsersApi, _BaseApi);

    function AppUsersApi() {
        _classCallCheck(this, AppUsersApi);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, _BaseApi.call.apply(_BaseApi, [this].concat(args)));

        _this.stripe = new (Function.prototype.bind.apply(_appUsersStripe.AppUsersStripeApi, [null].concat(args)))();
        _this.viber = new (Function.prototype.bind.apply(_appUsersViber.AppUsersViberApi, [null].concat(args)))();
        _this.wechat = new (Function.prototype.bind.apply(_appUsersWeChat.AppUsersWeChatApi, [null].concat(args)))();
        return _this;
    }

    /**
     * Initializes the conversation for a user
     * @param  {InitProps} props
     * @return {APIResponse}
     */


    AppUsersApi.prototype.init = function init(props) {
        var url = this.getFullURL('init');
        return this.request('POST', url, props);
    };

    AppUsersApi.prototype.create = function create(userId) {
        var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (!userId || !userId.trim()) {
            return Promise.reject(new Error('Must provide a userId.'));
        }

        var payload = Object.assign({
            userId: userId
        }, props);

        if (props.signedUpAt && !(props.signedUpAt instanceof Date)) {
            return Promise.reject(new Error('signedUpAt must be a date.'));
        }

        var url = this.getFullURL('appusers');

        // this endpoint only accepts JWT auth with app scope
        return this.request('POST', url, payload, {
            allowedAuth: ['jwt']
        });
    };

    /**
     * Fetch an app user
     * @param  {string} userId - a user id
     * @return {APIResponse}
     */


    AppUsersApi.prototype.get = function get(userId) {
        var url = this.getFullURL('appusers', userId);
        return this.request('GET', url);
    };

    /**
     * Update an app user
     * @param  {string} userId     - a user id
     * @param  {object} attributes - the attributes to update
     * @return {APIResponse}
     */


    AppUsersApi.prototype.update = function update(userId, attributes) {
        var url = this.getFullURL('appusers', userId);
        return this.request('PUT', url, attributes);
    };

    /**
     * Track an event for an app user
     * @param  {string} userId     - a user id
     * @param  {string} eventName  - the name of the event to track
     * @param  {object} {attributes} - attributes to update before tracking the event
     * @return {APIResponse}
     */


    AppUsersApi.prototype.trackEvent = function trackEvent(userId, eventName) {
        var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var url = this.getFullURL('appusers', userId, 'events');
        return this.request('POST', url, {
            name: eventName,
            appUser: attributes
        });
    };

    /**
     * Update the push notification token for a given app user's device
     * @param  {string} userId     - a user id
     * @param  {string} deviceId  - a device id
     * @param  {string} token  - a push notification token
     * @return {APIResponse}
     */


    AppUsersApi.prototype.updatePushToken = function updatePushToken(userId, deviceId, token) {
        var url = this.getFullURL('appusers', userId, 'pushToken');
        return this.request('POST', url, {
            deviceId: deviceId,
            token: token
        });
    };

    /**
    * Update the specified device for a given app user
    * @param {string} userId    - a user id
    * @param  {string} deviceId  - a device id
    * @param  {object} {attributes} - attributes to update on the device
    */


    AppUsersApi.prototype.updateDevice = function updateDevice(userId, deviceId, attributes) {
        var url = this.getFullURL('appusers', userId, 'devices', deviceId);
        return this.request('PUT', url, attributes);
    };

    /**
     * Links the specified channel to a user
     * @param {string} userId - a user id
     * @param {object} data - the data object
     * @return {APIResponse}
     */


    AppUsersApi.prototype.linkChannel = function linkChannel(userId, data) {
        if (!data.type) {
            return Promise.reject(new Error('Must provide a channel type.'));
        }

        var url = this.getFullURL('appUsers', userId, 'channels');
        return this.request('POST', url, data);
    };

    /**
     * Unlinks the specified channel
     * @param {string} userId - a user id
     * @param {string} channel - the channel to unlink
     * @return {APIResponse}
     */


    AppUsersApi.prototype.unlinkChannel = function unlinkChannel(userId, channel) {
        var url = this.getFullURL('appUsers', userId, 'channels', channel);
        return this.request('DELETE', url);
    };

    /**
     * Pings linked channel
     * @param {string} userId - a user id
     * @param {string} channel - the channel to ping
     * @return {APIResponse}
     */


    AppUsersApi.prototype.pingChannel = function pingChannel(userId, channel) {
        var url = this.getFullURL('appUsers', userId, 'integrations', channel, 'ping');
        return this.request('POST', url);
    };

    /**
     * Fetch app user's messages
     * @param  {string} userId - a user id
     * @param  {object} options - the paging parameters (before, after)
     * @return {APIResponse}
     */


    AppUsersApi.prototype.getMessages = function getMessages(userId) {
        var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var before = _ref.before;
        var after = _ref.after;

        if (before && after) {
            return Promise.reject(new Error('Parameters "before" and "after" are mutually exclusive. You must provide one or the other.'));
        }

        var url = this.getFullURL('appUsers', userId, 'messages');

        var params = void 0;

        if (before) {
            params = {
                before: before
            };
        } else if (after) {
            params = {
                after: after
            };
        }

        return this.request('GET', url, params);
    };

    /**
     * Send a message to an app user's conversation
     * @param  {string} userId - a user id
     * @param  {Message} message - the message to be sent
     * @return  {APIResponse}
     */


    AppUsersApi.prototype.sendMessage = function sendMessage(userId, message) {
        var url = this.getFullURL('appUsers', userId, 'messages');
        return this.request('POST', url, message);
    };

    /**
     * Send an image to an app user's conversation
     * @param  {string} userId - a user id
     * @param  {Blob|Readable stream} source - source image
     * @param  {Message} message - the message to be sent
     * @return {APIResponse}
     */


    AppUsersApi.prototype.uploadImage = function uploadImage(userId, source) {
        var message = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var url = this.getFullURL('appUsers', userId, 'images');
        var data = new FormData();
        data.append('source', source);

        Object.keys(message).forEach(function (key) {
            data.append(key, message[key]);
        });

        return this.request('POST', url, data);
    };

    return AppUsersApi;
}(_base.BaseApi);